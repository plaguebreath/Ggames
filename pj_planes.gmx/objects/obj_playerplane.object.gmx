<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sp_fokkerbody</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//var em_player;

depth = -100;
image_xscale = 0.50; // xscale of image
image_yscale = 0.50; // yscale of image
//image_index = 0;

timeInitrefuel = current_time; // initialize the Refuel event time
timeCurrentrefuel = current_time; // Refuel current event time
timebeforerefuel = 50; // set intervall between refuel
MAX_planefuel = 1000 // Gallon of fuel for plane to fly
planefuel = MAX_planefuel;

//Instance plane variables
planemovement = 0; // 0 fly forward 1 fly up -1 fly down
standardspriteyscale = image_yscale;
 
isreloading = false; // Check if plane is still reloading bullets bombs and fuel
isplanetakeoff = true; // Check if plane is on the take off situation where speed &gt; takeoffspeed and not touch the runway
isplanelanded = true; // Check if plane is stop and on runway
isplaneonrunway = true; // Check collision on runway 
isplanecrashed = false; // Check for crash of plane
isplanestall = false; // Check if plane go in stall after reach altitude of room + global.stallroomlimity
isflipped = false; // Check flip of the plane when reach border of the room
speedplanemax = 10; // Set up max speed of the plane
turnfactor = 2; // Set che max turn of the plane when pressing up and down
turnvalue = 0; // set default value of turn
oldturnvalue = 0; // Variabile for track if the plane is moving forward or still rolling
takeoffspeed = 5; // Set the take off speed for allow plane to go up from the runway 
facceleration = 0; // Set acceleration value of plane
fvalue = 0; // Set the value of force applied to plane based on the facceleration and some other parameters
MAX_fvalue = 0.07;
MIN_fvalue = -0.07;
enginestarted = false; // Set the enginestart event
altitude = 0; // Value for check the altitude of the plane

timeInitmg = current_time; // initialize the MG fire event time
timeCurrentmg = current_time; // MG fire current event time
fireintervalmg = 200; // interval between fire in milliseconds
offsetlenmg = 32;  // position x offset of MG
timeInitjammed = current_time; // initialize the Jammed MG event time
timeCurrentjammed = current_time; // Jammed MG current event time
jammedintervalmg = 2000;  // interval of time before exit the Jammed condition, in milliseconds
ismgjammed = false; // Check if MG is jammed or not
isfiremg = false; // check for animation of mg firing

timeInitbomb = current_time; // initialize the BOMB fire event time
timeCurrentbomb = current_time; // BOMB fire current event time
fireintervalbomb = 1000; // interval between fire in milliseconds
offsetlenbomb = -5;  // position x offset of BOMB

timebeforereloadbullets = 250; // set intervall between reloading bullets of MG
timeInitbullets = current_time; // initialize the MG reload event time
timeCurrentbullets = current_time; // MG reload current event time
MAX_bullets = 500; // set max bullets of MG
bullets = MAX_bullets; // set counter bullets of MG
timebeforereloadbombs = 500; // set intervall between reloading BOMBS
timeInitbombs = current_time; // initialize the BOMB reload event time
timeCurrentbombs = current_time; // BOMB reload current event time
MAX_bombs = 10; // set max BOMBS
bombs = MAX_bombs; // set counter BOMBS

timeInitlanded  = current_time; // initialize the Landing event time
timeCurrentlanded = current_time; // Landing current event time
timeonrunway = 3000; // interval of time to pass after plane stoped on runway considered landed, in milliseconds

timeInitstall = current_time; // initialize the Stall event time
timeCurrentstall = current_time; // Stall current event time
timeforstall = 2000; // interval of time before exit the Stall condition, in milliseconds

timeInitflip = current_time; // initialize the Flip event time
timeCurrentflip = current_time; // Flip current event time
timeforflip = 1000; // interval of time before trigger the Flip condition, in milliseconds

gravityplane = 0.20; // Set the gravity applied to the plane at the beginning

global.restart = false; // Set the restart flag for player

soundexplosionplayed=0; // Set if the explosion sound played
  
em_player =  audio_emitter_create(); // Emitter audio connected to the plane

p_propeller = instance_create(x,y,obj_propeller); // Create instance of the propeller of the plane
p_propeller.image_xscale = image_xscale; // Set x scale of propeller same as the plane
p_propeller.image_yscale = image_yscale; // Set y scale of propeller same as the plane

audio_listener_orientation(x, y, 1000, 0, 0, -1); // Set the listener position toward sound emitters

scr_planesetonrunway(id); //Call reset position on runway

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with (p_propeller)
    {
     //visible = false;    
     instance_destroy();
    }
audio_emitter_free(em_player);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>view_xview = ((x -view_wview/2)+view_xview*9)/10 + hspeed
view_yview = ((y -view_hview/2)+view_yview*9)/10 + vspeed

if view_xview &lt; 0
    view_xview = 0
if view_yview &lt; 0
    view_yview = 0
if view_xview &gt; room_width-view_wview
    view_xview = room_width-view_wview
if view_yview &gt; room_height-view_hview
    view_yview = room_height-view_hview
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//image_speed = 1;
//var turnvalue = 0;
// var fvalue = 0;
//var stallroomlimity = 100;

if (global.restart){
  scr_restart(id);
}else{
  //On press of BackSpace reset position of plane
  if keyboard_check_pressed(vk_backspace){
    global.restart = true;
  }else{
     // Collisions check on runway
     //show_debug_message(y + vspeed + 2);
     //show_debug_message(obj_runway.y);
    //if  place_meeting(x,y + vspeed + 2 ,obj_runway){
     
     if  place_meeting(x,y + vspeed ,obj_runway){   
     if (!isplaneonrunway &amp;&amp; !isplanecrashed) y += (vspeed + 2);    
      // if (!isplaneonrunway &amp;&amp; !isplanecrashed){
      //  if (direction &lt;= 330){ direction = 10} else direction  = 135;
      //}    
      // funziona 
      ////if (!isplaneonrunway &amp;&amp; !isplanecrashed) y += vspeed + 2;                
      if (!isflipped &amp;&amp; (direction &gt;= 330 || direction &lt;= 30)) || (isflipped &amp;&amp; (direction &gt;= 150 &amp;&amp; direction &lt;= 210)) {
        isplaneonrunway = true;
      }else{
       isplanecrashed = true;
      }
      
      //funziona if (!isplaneonrunway &amp;&amp; !isplanecrashed) y += 5;                   
    }else{ // Collision check on the ground
      if  place_meeting(x,y+vspeed -10,obj_ground){
        isplanecrashed = true;
      }else{
        if (room_height - y &gt; room_height + global.stallroomlimity){
          isplanestall = true;
          direction = 270;
          speed = 0;  
        }
        //aereo crashato
        if (room_height - y &lt;= 0){
          isplanecrashed = true;
        } 
        isplaneonrunway = false;
        isplanetakeoff = false;
      }
    }
    //if (isplanecrashed){
    //  // Process sounds of crash
    //  scr_planesound(id,2);       
    //}         
    // Check if plane is just landed
    scr_isplanelanded(id);
    // if it's just landed then procede to reloading if needed
    if (isreloading) scr_refuel(id);    
    if (isplanestall) scr_planestall(id);     
    // Process Movements
    scr_moveplane(id);
    // Movement logic
    scr_movelogic(id);
    // Check for Border bump and orientation
    scr_borderandflip(id);       
    // Process sounds of engine
    scr_planesound(id,0);    
  }
  scr_ctrlpropeller(id);
}

// Update Values of variables
altitude = room_height - y  - 5 - (sprite_height*image_yscale) / 2 ;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Draw self based on Sprite

var sprdefault_begin = 0;
var sprdefault_end = 2;
var sprup_begin = 3;
var sprup_end = 5;
var sprdown_begin = 6;
var sprdown_end = 8;

var spr_begin = 0;
var spr_end = 0;

sprite_index = sp_fokkerbody;

if (!isplanecrashed){
  switch (planemovement){
   case 0:  // plane forward
      spr_begin = sprdefault_begin;
      spr_end = sprdefault_end;    
      break;
      
   case 1: // plane up
      spr_begin = sprup_begin;
      spr_end = sprup_end;    
      break;
       
   case -1: // plane down
     spr_begin = sprdown_begin;
     spr_end = sprdown_end;    
     break;
  }
  // Drawing event 
  if (isfiremg){      
    image_speed = 0.4;
    if (image_index &gt; spr_end){
      image_index = spr_begin;
      isfiremg = false;
    }else if (image_index &lt; spr_begin)  image_index = spr_begin;
  }else{  
    image_index = spr_begin;
    image_speed = 0;
  }  
  image_angle = direction; 
  draw_sprite_ext(sprite_index,image_index,x,y,image_xscale,image_yscale,image_angle,-1,1)
}else{
  sprite_index = sp_fokkercrash;
  image_speed = 0.4;
  if (image_index &gt;= image_number - 1) {
    image_index = 3;
    image_speed = 0;
  }
  draw_self()
}
//Draw Bounding Box around Object
draw_rectangle(bbox_left,bbox_top,bbox_right,bbox_bottom,1)

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
